# 犁地阻力测试用例详细设计

## 1. 测试用例概述

### 1.1 测试目标
验证VCU在犁地过程中遇到突发高阻力时的智能决策能力，确保系统能够：
- 快速检测异常阻力情况
- 协调多个子系统进行最优响应
- 保护设备免受损害
- 自动恢复到正常作业状态

### 1.2 测试重要性
这是VCU系统最核心的智能决策能力验证，直接关系到：
- **作业效率**: 能否在困难条件下继续作业
- **设备保护**: 避免发动机过载、传动系统损坏
- **燃油经济性**: 智能调节减少不必要的能耗
- **作业质量**: 保持一致的犁地深度和效果

## 2. 物理模型设计

### 2.1 土壤阻力模型

#### 基础阻力计算公式
```
F_draft = K × W × D × V^n × f_soil × f_moisture × f_resistance
```

**参数说明**:
- `K`: 土壤比阻力系数 (N/m²)
- `W`: 犁具工作宽度 (m)
- `D`: 犁地深度 (m)  
- `V`: 行驶速度 (m/s)
- `n`: 速度指数 (通常为1.2-1.5)
- `f_soil`: 土壤类型系数
- `f_moisture`: 土壤湿度系数
- `f_resistance`: 动态阻力系数

#### 阻力变化曲线设计

```cpp
double calculateResistanceFactor(double time) {
    if (time < 30.0) {
        // 阶段1: 正常土壤 (0-30s)
        return 1.0;
        
    } else if (time < 35.0) {
        // 阶段2: 阻力急剧上升 (30-35s)
        // 模拟遇到硬土层的瞬间冲击
        double t_norm = (time - 30.0) / 5.0;
        return 1.0 + 3.5 * (1.0 - exp(-5.0 * t_norm));
        
    } else if (time < 45.0) {
        // 阶段3: 高阻力持续 (35-45s)
        // 模拟在硬土层中艰难前进
        return 4.5 + 0.5 * sin(2.0 * M_PI * (time - 35.0));
        
    } else if (time < 60.0) {
        // 阶段4: 阻力逐渐减小 (45-60s)
        // 模拟逐渐通过障碍
        double t_norm = (time - 45.0) / 15.0;
        return 4.5 * exp(-2.0 * t_norm) + 1.0 * (1.0 - exp(-2.0 * t_norm));
        
    } else {
        // 阶段5: 恢复正常 (60s+)
        return 1.0;
    }
}
```

### 2.2 动力总成负载模型

#### 负载扭矩计算
```cpp
class PowertrainLoadModel {
private:
    double calculateDraftTorque(double draft_force) {
        // 犁具到PTO的等效半径
        double effective_radius = 1.2; // m
        return draft_force * effective_radius;
    }
    
    double calculateInertialTorque(double acceleration) {
        // 旋转惯量效应
        double rotational_inertia = 15.0; // kg⋅m²
        return rotational_inertia * acceleration;
    }
    
    double calculateFrictionTorque(double speed) {
        // 摩擦损失
        double friction_coefficient = 0.02;
        return friction_coefficient * speed * speed;
    }
    
public:
    double getTotalLoadTorque(double draft_force, double speed, double acceleration) {
        double draft_torque = calculateDraftTorque(draft_force);
        double inertial_torque = calculateInertialTorque(acceleration);
        double friction_torque = calculateFrictionTorque(speed);
        
        return draft_torque + inertial_torque + friction_torque;
    }
};
```

## 3. VCU智能决策算法设计

### 3.1 异常检测算法

#### 多层次检测机制
```cpp
class AnomalyDetector {
private:
    double load_threshold_absolute_ = 150.0;    // Nm
    double load_rate_threshold_ = 50.0;         // Nm/s
    double detection_window_ = 0.5;             // s
    
    std::deque<double> load_history_;
    std::deque<double> time_history_;
    
public:
    bool detectAnomaly(double current_load, double current_time) {
        // 更新历史数据
        load_history_.push_back(current_load);
        time_history_.push_back(current_time);
        
        // 保持窗口大小
        while (time_history_.size() > 0 && 
               current_time - time_history_.front() > detection_window_) {
            load_history_.pop_front();
            time_history_.pop_front();
        }
        
        if (load_history_.size() < 2) return false;
        
        // 检测1: 绝对负载阈值
        bool absolute_threshold = current_load > load_threshold_absolute_;
        
        // 检测2: 负载变化率
        double load_rate = (load_history_.back() - load_history_.front()) / 
                          (time_history_.back() - time_history_.front());
        bool rate_threshold = load_rate > load_rate_threshold_;
        
        // 检测3: 趋势分析
        bool trend_analysis = analyzeTrend();
        
        return absolute_threshold && (rate_threshold || trend_analysis);
    }
    
private:
    bool analyzeTrend() {
        if (load_history_.size() < 5) return false;
        
        // 简单线性回归检测上升趋势
        double sum_x = 0, sum_y = 0, sum_xy = 0, sum_x2 = 0;
        int n = load_history_.size();
        
        for (int i = 0; i < n; i++) {
            sum_x += i;
            sum_y += load_history_[i];
            sum_xy += i * load_history_[i];
            sum_x2 += i * i;
        }
        
        double slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x);
        return slope > 20.0; // 上升趋势阈值
    }
};
```

### 3.2 多目标优化决策算法

#### 决策目标函数
```cpp
class MultiObjectiveOptimizer {
private:
    struct OptimizationWeights {
        double equipment_protection = 0.4;    // 设备保护权重
        double work_efficiency = 0.3;         // 作业效率权重  
        double fuel_economy = 0.2;            // 燃油经济性权重
        double work_quality = 0.1;            // 作业质量权重
    } weights_;
    
public:
    struct ControlParameters {
        double engine_torque_ratio;    // 发动机扭矩比例 (0.6-1.0)
        double cvt_ratio;              // CVT传动比 (0.8-2.0)
        double plow_depth_ratio;       // 犁地深度比例 (0.3-1.0)
        double vehicle_speed_ratio;    // 车速比例 (0.5-1.0)
        double motor_assist_ratio;     // 电机辅助比例 (0.0-0.6)
    };
    
    ControlParameters optimize(double current_load, double target_load) {
        ControlParameters params;
        
        // 计算负载比例
        double load_ratio = current_load / target_load;
        
        if (load_ratio > 2.0) {
            // 高负载情况：优先保护设备
            params = optimizeForProtection(load_ratio);
        } else if (load_ratio > 1.5) {
            // 中等负载：平衡效率和保护
            params = optimizeForBalance(load_ratio);
        } else {
            // 正常负载：优化效率
            params = optimizeForEfficiency(load_ratio);
        }
        
        return params;
    }
    
private:
    ControlParameters optimizeForProtection(double load_ratio) {
        ControlParameters params;
        
        // 设备保护优先策略
        params.engine_torque_ratio = std::min(0.95, 0.6 + 0.2 * (load_ratio - 1.0));
        params.cvt_ratio = std::max(0.8, 2.0 - 0.3 * load_ratio);
        params.plow_depth_ratio = std::max(0.4, 1.2 - 0.2 * load_ratio);
        params.vehicle_speed_ratio = std::max(0.6, 1.1 - 0.15 * load_ratio);
        params.motor_assist_ratio = std::min(0.5, 0.1 * (load_ratio - 1.5));
        
        return params;
    }
    
    ControlParameters optimizeForBalance(double load_ratio) {
        ControlParameters params;
        
        // 平衡策略
        params.engine_torque_ratio = 0.7 + 0.15 * (load_ratio - 1.0);
        params.cvt_ratio = 1.8 - 0.2 * load_ratio;
        params.plow_depth_ratio = 1.0 - 0.1 * (load_ratio - 1.0);
        params.vehicle_speed_ratio = 1.0 - 0.1 * (load_ratio - 1.0);
        params.motor_assist_ratio = 0.05 * (load_ratio - 1.2);
        
        return params;
    }
    
    ControlParameters optimizeForEfficiency(double load_ratio) {
        ControlParameters params;
        
        // 效率优先策略
        params.engine_torque_ratio = 0.65 + 0.1 * load_ratio;
        params.cvt_ratio = 1.5;
        params.plow_depth_ratio = 1.0;
        params.vehicle_speed_ratio = 1.0;
        params.motor_assist_ratio = 0.0;
        
        return params;
    }
};
```

### 3.3 自适应恢复算法

#### 渐进式参数恢复
```cpp
class AdaptiveRecoveryController {
private:
    struct RecoveryState {
        double target_depth;
        double target_speed;
        double target_cvt_ratio;
        double target_engine_load;
        bool hybrid_mode_active;
    } recovery_targets_;
    
    struct RecoveryRates {
        double depth_rate = 0.01;      // m/s
        double speed_rate = 0.5;       // km/h/s
        double cvt_rate = 0.1;         // ratio/s
        double engine_rate = 0.05;     // load%/s
        double motor_rate = 10.0;      // Nm/s
    } recovery_rates_;
    
public:
    void updateRecovery(ControlParameters& current, double dt, double current_load) {
        // 检查是否可以开始恢复
        if (!canStartRecovery(current_load)) {
            return;
        }
        
        // 渐进式恢复各参数
        recoverDepth(current, dt);
        recoverSpeed(current, dt);
        recoverCVTRatio(current, dt);
        recoverEngineLoad(current, dt);
        recoverMotorAssist(current, dt);
        
        // 检查恢复完成
        checkRecoveryCompletion(current);
    }
    
private:
    bool canStartRecovery(double current_load) {
        return current_load < 120.0; // 负载降到正常水平
    }
    
    void recoverDepth(ControlParameters& current, double dt) {
        if (current.plow_depth_ratio < recovery_targets_.target_depth) {
            double increment = recovery_rates_.depth_rate * dt / 0.25; // 归一化
            current.plow_depth_ratio = std::min(recovery_targets_.target_depth,
                                              current.plow_depth_ratio + increment);
        }
    }
    
    void recoverSpeed(ControlParameters& current, double dt) {
        if (current.vehicle_speed_ratio < recovery_targets_.target_speed) {
            double increment = recovery_rates_.speed_rate * dt / 8.0; // 归一化到8km/h
            current.vehicle_speed_ratio = std::min(recovery_targets_.target_speed,
                                                 current.vehicle_speed_ratio + increment);
        }
    }
    
    // ... 其他恢复函数类似实现
};
```

## 4. 测试场景设计

### 4.1 时间轴设计

```
时间轴 (180秒总测试时间):

0s     30s    35s    45s    60s    90s    180s
│──────│──────│──────│──────│──────│──────│
│ 正常 │ 冲击 │ 高阻 │ 减小 │ 恢复 │ 优化 │
│ 作业 │ 检测 │ 力期 │ 阶段 │ 阶段 │ 阶段 │

阶段详细说明:
- 0-30s:  正常犁地，建立基线数据
- 30-35s: 阻力冲击，VCU检测和初始响应
- 35-45s: 高阻力持续，VCU深度调节
- 45-60s: 阻力减小，VCU准备恢复
- 60-90s: 参数恢复，逐步回到正常
- 90-180s: 优化阶段，微调参数
```

### 4.2 关键时间点验证

```cpp
struct TestCheckpoints {
    // 异常检测检查点
    struct {
        double time = 32.0;           // 检测完成时间
        double max_detection_time = 2.0;
        bool detection_required = true;
    } anomaly_detection;
    
    // 紧急响应检查点
    struct {
        double time = 35.0;
        double min_torque_increase = 0.2;  // 20%
        double max_cvt_ratio = 1.2;
        bool hybrid_activation_required = true;
    } emergency_response;
    
    // 深度调节检查点
    struct {
        double time = 40.0;
        double min_depth_reduction = 0.15; // 15%
        double max_speed_reduction = 0.3;  // 30%
    } depth_adjustment;
    
    // 恢复开始检查点
    struct {
        double time = 65.0;
        double max_load_threshold = 120.0; // Nm
        bool recovery_start_required = true;
    } recovery_start;
    
    // 恢复完成检查点
    struct {
        double time = 90.0;
        double depth_tolerance = 0.02;     // ±2cm
        double speed_tolerance = 0.5;      // ±0.5km/h
        bool hybrid_deactivation_required = true;
    } recovery_completion;
};
```

## 5. 验证方法设计

### 5.1 实时性能监控

```cpp
class PerformanceMonitor {
private:
    struct PerformanceMetrics {
        // 响应时间指标
        double anomaly_detection_time = -1.0;
        double torque_response_time = -1.0;
        double depth_adjustment_time = -1.0;
        
        // 控制精度指标
        double max_engine_torque = 0.0;
        double min_plow_depth = 1.0;
        double max_speed_reduction = 0.0;
        
        // 稳定性指标
        double torque_variance = 0.0;
        double depth_variance = 0.0;
        int oscillation_count = 0;
        
        // 效率指标
        double fuel_consumption_increase = 0.0;
        double work_efficiency_loss = 0.0;
        double recovery_efficiency = 0.0;
    } metrics_;
    
public:
    void updateMetrics(double time, const SystemState& state) {
        // 更新响应时间指标
        updateResponseTimes(time, state);
        
        // 更新控制精度指标
        updateControlAccuracy(state);
        
        // 更新稳定性指标
        updateStabilityMetrics(state);
        
        // 更新效率指标
        updateEfficiencyMetrics(time, state);
    }
    
    bool validatePerformance() {
        bool passed = true;
        
        // 验证响应时间
        if (metrics_.anomaly_detection_time > 2.0) {
            std::cout << "❌ 异常检测时间过长: " 
                      << metrics_.anomaly_detection_time << "s" << std::endl;
            passed = false;
        }
        
        // 验证控制精度
        if (metrics_.max_engine_torque < 288.0) { // 240 * 1.2
            std::cout << "❌ 发动机扭矩响应不足: " 
                      << metrics_.max_engine_torque << "Nm" << std::endl;
            passed = false;
        }
        
        // 验证稳定性
        if (metrics_.oscillation_count > 3) {
            std::cout << "❌ 系统振荡次数过多: " 
                      << metrics_.oscillation_count << std::endl;
            passed = false;
        }
        
        return passed;
    }
};
```

### 5.2 数据记录和分析

```cpp
class TestDataLogger {
private:
    std::ofstream log_file_;
    std::vector<DataPoint> data_points_;
    
    struct DataPoint {
        double timestamp;
        double soil_resistance_factor;
        double engine_speed;
        double engine_torque;
        double engine_throttle;
        double motor_torque;
        double cvt_ratio;
        double vehicle_speed;
        double plow_depth_target;
        double plow_depth_actual;
        double plow_load_torque;
        double battery_soc;
        double fuel_consumption_rate;
        int vcu_decision_state;
        std::string system_warnings;
    };
    
public:
    void logData(double time, const SystemState& state) {
        DataPoint point;
        point.timestamp = time;
        // ... 填充所有数据字段
        
        data_points_.push_back(point);
        
        // 写入CSV文件
        log_file_ << time << "," 
                  << state.soil_resistance_factor << ","
                  << state.engine_torque << ","
                  // ... 其他字段
                  << std::endl;
    }
    
    void generateAnalysisReport() {
        // 生成详细的分析报告
        std::ofstream report("test_analysis_report.html");
        
        report << generateHTMLHeader();
        report << generateTimeSeriesCharts();
        report << generatePerformanceAnalysis();
        report << generateRecommendations();
        report << generateHTMLFooter();
    }
    
private:
    std::string generateTimeSeriesCharts() {
        // 生成时间序列图表的HTML/JavaScript代码
        std::string charts = R"(
        <div id="torque_chart"></div>
        <script>
        var torque_data = [
        )";
        
        for (const auto& point : data_points_) {
            charts += "{x: " + std::to_string(point.timestamp) + 
                     ", y: " + std::to_string(point.engine_torque) + "},";
        }
        
        charts += R"(
        ];
        // Plotly.js 图表代码
        </script>
        )";
        
        return charts;
    }
};
```

## 6. 测试执行流程

### 6.1 自动化测试流程

```cpp
class AutomatedTestRunner {
public:
    bool runCompleteTest() {
        std::cout << "=== 开始犁地阻力智能决策测试 ===" << std::endl;
        
        // 1. 初始化测试环境
        if (!initializeTestEnvironment()) {
            return false;
        }
        
        // 2. 执行测试场景
        bool scenario_passed = executeTestScenario();
        
        // 3. 验证测试结果
        bool validation_passed = validateTestResults();
        
        // 4. 生成测试报告
        generateTestReport(scenario_passed && validation_passed);
        
        return scenario_passed && validation_passed;
    }
    
private:
    bool initializeTestEnvironment() {
        // 初始化仿真模型
        powertrain_model_.reset();
        plow_model_.reset();
        environment_model_.reset();
        vcu_controller_.reset();
        
        // 加载测试配置
        if (!loadTestConfiguration("critical_plow_resistance_test.yaml")) {
            std::cout << "❌ 测试配置加载失败" << std::endl;
            return false;
        }
        
        // 初始化数据记录
        data_logger_.initialize("plow_resistance_test_data.csv");
        performance_monitor_.reset();
        
        return true;
    }
    
    bool executeTestScenario() {
        const double dt = 0.01; // 10ms仿真步长
        const double total_time = 180.0; // 3分钟
        
        for (double time = 0.0; time < total_time; time += dt) {
            // 更新环境条件
            double resistance_factor = calculateResistanceFactor(time);
            environment_model_.setResistanceFactor(resistance_factor);
            
            // 更新物理模型
            plow_model_.update(dt);
            powertrain_model_.update(dt);
            
            // VCU决策
            double current_load = plow_model_.getLoadTorque();
            vcu_controller_.makeDecision(current_load, dt, 
                                       powertrain_model_, plow_model_);
            
            // 记录数据
            SystemState state = collectSystemState();
            data_logger_.logData(time, state);
            performance_monitor_.updateMetrics(time, state);
            
            // 实时输出
            if (static_cast<int>(time * 100) % 50 == 0) {
                printProgress(time, state);
            }
        }
        
        return true;
    }
};
```

### 6.2 测试报告生成

```cpp
class TestReportGenerator {
public:
    void generateComprehensiveReport(const TestResults& results) {
        std::ofstream report("plow_resistance_test_report.html");
        
        report << generateReportHeader();
        report << generateExecutiveSummary(results);
        report << generateDetailedAnalysis(results);
        report << generatePerformanceCharts(results);
        report << generateRecommendations(results);
        report << generateAppendix(results);
        report << generateReportFooter();
        
        std::cout << "📊 详细测试报告已生成: plow_resistance_test_report.html" << std::endl;
    }
    
private:
    std::string generateExecutiveSummary(const TestResults& results) {
        std::string summary = R"(
        <h2>执行摘要</h2>
        <div class="summary-box">
            <h3>测试结果: )" + (results.overall_passed ? "✅ 通过" : "❌ 失败") + R"(</h3>
            <table class="summary-table">
                <tr><td>异常检测时间</td><td>)" + std::to_string(results.detection_time) + R"(s</td></tr>
                <tr><td>最大发动机扭矩</td><td>)" + std::to_string(results.max_engine_torque) + R"(Nm</td></tr>
                <tr><td>犁地深度调整</td><td>)" + std::to_string(results.depth_reduction * 100) + R"(%</td></tr>
                <tr><td>系统恢复时间</td><td>)" + std::to_string(results.recovery_time) + R"(s</td></tr>
            </table>
        </div>
        )";
        
        return summary;
    }
    
    std::string generatePerformanceCharts(const TestResults& results) {
        // 生成交互式性能图表
        return R"(
        <h2>性能分析图表</h2>
        <div id="torque_timeline_chart"></div>
        <div id="depth_adjustment_chart"></div>
        <div id="decision_state_chart"></div>
        
        <script>
        // 扭矩时间线图表
        var torque_data = {
            x: [)" + generateTimeArray() + R"(],
            y: [)" + generateTorqueArray() + R"(],
            type: 'scatter',
            mode: 'lines',
            name: '发动机扭矩'
        };
        
        var layout = {
            title: 'VCU智能决策过程 - 发动机扭矩响应',
            xaxis: { title: '时间 (s)' },
            yaxis: { title: '扭矩 (Nm)' }
        };
        
        Plotly.newPlot('torque_timeline_chart', [torque_data], layout);
        </script>
        )";
    }
};
```

## 7. 预期测试结果

### 7.1 成功标准

| 测试项目 | 目标值 | 最低要求 | 评分权重 |
|----------|--------|----------|----------|
| **异常检测时间** | <1.5s | <2.0s | 20% |
| **发动机扭矩响应** | >25% | >20% | 25% |
| **犁地深度调整** | >20% | >15% | 20% |
| **混合动力激活** | 是 | 是 | 15% |
| **系统恢复时间** | <25s | <30s | 15% |
| **系统稳定性** | 无振荡 | <3次振荡 | 5% |

### 7.2 典型测试输出

```
=== VCU智能决策测试：犁地突发阻力场景 ===

[30.0s] 负载:85.2Nm 阻力系数:1.0 状态:0 深度:0.25m 速度:8.0km/h
[30.5s] 负载:142.8Nm 阻力系数:2.1 状态:0 深度:0.25m 速度:8.0km/h
[31.0s] 负载:198.5Nm 阻力系数:3.2 状态:1 深度:0.25m 速度:8.0km/h
[VCU] 检测到异常阻力! 负载: 198.5Nm, 变化率: 67.4Nm/s
[31.5s] 负载:245.1Nm 阻力系数:4.1 状态:2 深度:0.24m 速度:7.8km/h
[VCU] 确认高阻力情况，启动紧急响应
[32.0s] 负载:278.9Nm 阻力系数:4.5 状态:2 深度:0.23m 速度:7.5km/h
[VCU] 启用混合动力模式，电机辅助扭矩: 80Nm
[35.0s] 负载:312.4Nm 阻力系数:4.6 状态:3 深度:0.21m 速度:6.8km/h
[VCU] 紧急响应模式 - 调整动力系统参数
...
[45.0s] 负载:245.7Nm 阻力系数:3.8 状态:3 深度:0.20m 速度:6.5km/h
[VCU] 阻力减小，准备进入恢复模式
[60.0s] 负载:98.3Nm 阻力系数:1.0 状态:4 深度:0.20m 速度:6.5km/h
[VCU] 恢复模式 - 逐步恢复作业参数
...
[87.3s] 负载:89.1Nm 阻力系数:1.0 状态:5 深度:0.25m 速度:8.0km/h
[VCU] 完全恢复正常作业状态

=== 测试结果分析 ===
✅ 异常检测时间: 1.0s (目标<1.5s)
✅ 最大发动机扭矩: 312.4Nm (增加30.2%, 目标>25%)
✅ 犁地深度减少: 20.0% (目标>20%)
✅ 混合动力模式已激活
✅ 系统恢复时间: 27.3s (目标<30s)
✅ 系统稳定性: 无振荡

总体评分: 96/100 ✅ 优秀
```

这个详细的测试用例设计涵盖了从物理建模到算法实现，从测试执行到结果验证的完整流程，确保VCU智能决策能力得到全面、准确的验证。
